bplist00Ò_WebMainResource_WebSubresourcesÕ	
_WebResourceData_WebResourceMIMEType_WebResourceTextEncodingName^WebResourceURL_WebResourceFrameNameOÓk<!DOCTYPE html><html><head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <link rel="stylesheet" href="/style.css">
    <link rel="icon" type="image/png" href="/favicon.png">
    <link rel="alternate" type="application/atom+xml" href="/updates.xml">
    <title>
The Recogniser
</title>
    <meta name="description" content="
The first step: determining if the input is valid at all.  Beware, I left a nasty bug in there.
">
  </head>
  <body>
    <header>
      <img id="logo" width="136" height="150" border="0" src="/penrose.png" alt="logo">
      <h1>@ Loup's</h1>
      <blockquote><p>Impossible?  Like that would stop me.</p></blockquote>
    </header>

    <article> 
<h1>Earley Parsing Explained â€” The Recogniser</h1>

<p>(The impatient may download the <a href="recogniser.lua">source code</a>.)</p>

<p>We will use this grammar:</p>

<pre><code>Sum     = Sum     [+-] Product
        | Product
Product = Product [*/] Factor
        | Factor
Factor  = '(' Sum ')'
        | Number
Number  = [0-9]+
</code></pre>

<p>However, Earley parsers don't recognise EBNF grammars directly.  We
need to use this restricted syntax:</p>

<pre><code>Sum     -&gt; Sum     [+-] Product
Sum     -&gt; Product
Product -&gt; Product [*/] Factor
Product -&gt; Factor
Factor  -&gt; '(' Sum ')'
Factor  -&gt; Number
Number  -&gt; [0-9] Number
Number  -&gt; [0-9]
</code></pre>

<p>Don't worry, this notation is just as powerful as the full EBNF.  We
will automate the translation process <a href="handling-bnf">later</a>.</p>

<h2>Vocabulary</h2>

<h3>Grammars, rules, and symbols</h3>

<p>For the purposes of Earley parsing, a <em>grammar</em> is a set of <em>rules</em>.
Here is a rule:</p>

<pre><code>Product -&gt; Product [*/] Factor
</code></pre>

<p>The left hand side of a rule (<code>Product</code> in this example) is called a
<em>non-terminal symbol</em>.  The right hand side (<code>Product&nbsp;[*/]&nbsp;Factor</code> in
this example) is a list of symbols: non-terminal symbols (<code>Product</code>
and <code>Factor</code> in this example), and <em>terminal symbols</em> (<code>[*/]</code> in this
example).</p>

<p>A terminal symbol is a function from characters to booleans.  It tells
you if a given character matches.  Popular short hands for such
functions look like <code>'x'</code> (matches the character 'x' only), or
<code>[+-*/]</code> (matches '+', '-', '*', and '/'), or <code>[0-9]</code> (matches all
numbers).</p>

<h3>Earley items</h3>

<p>I said previously that chart parsers construct lists of partial
parses.  Earley parsers are no exception.  They just call those
partial parses <em>Earley items</em>. Here is an Earley item:</p>

<pre><code>Sum -&gt; Sum â€¢ [+-] Product  (0)
</code></pre>

<p>It is just like a grammar rule, with a couple more things: a fat dot
somewhere in the right hand side, and a number at the far right.  And
of course, it represents a partial parse.  Here is another way to view
this item:</p>

<pre><code> â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”Œâ”¤ Sum -&gt; Sum â”‚ [+-] Product â”œâ”€â”€&gt;?
â”‚â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚             V
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”
â”‚      1      â”‚  +  â”‚  (  â”‚  2  â”‚  *  â”‚  3  â”‚  -  â”‚  4  â”‚  )  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜
              ^
              â””â”€ current position
</code></pre>

<ul>
<li>The number between the parentheses represents where the item
<em>starts</em>.  <code>(0)</code> means it starts at the beginning of the input.</li>
<li>The fat dot represent <em>how much</em> has been parsed so far.  Whatever
lies on its left is <em>done</em>.  Whatever lies on its right has yet to
be tested.  In this example, the very next thing to test is the
terminal token <code>[+-]</code>.</li>
</ul>

<p>The astute reader may have noticed a key piece of information that I
have represented in the chart, yet is conspicuously absent from the
item itself: the current position.  This information is crucial, but
Earley's algorithm doesn't need the items to store their own current
position.  That's because all the items with the same current position
are stored together in a <em>state set</em>. (I don't know why nobody calls
them "item sets" instead.  Whatever.)  That state set is itself stored
in an array.  Its position in that array denotes the current position
of the Earley items.</p>

<p>If you are able to look at a particular item, you know its current
position, because that's how you found it in the first place.</p>

<h3>State sets</h3>

<p>State sets are kind of weird.  They are sets all right, in the sense
that they don't contain multiple copies of the same item.  On the
other hand, for the purpose of Earley's algorithm, it is easier to
think of them as <a href="https://en.wikipedia.org/wiki/Dynamic_array" title="Wikipedia">dynamic arrays</a>.</p>

<p>Those state sets are stored in a big dynamic array, generally simply
called 'S'.  Here is a possible representation.</p>

<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”
â”‚ S(0) â”‚ S(1) â”‚ S(2) â”‚ &lt;â”€â”€ the outer array, called 'S'
â””â”€â”€â”¬â”€â”€â”€â”´â”€â”€â”¬â”€â”€â”€â”´â”€â”€â”¬â”€â”€â”€â”˜
   â”‚      â”‚      â”‚
   â”‚      â”‚      V
   â”‚      â”‚   â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”
   â”‚      â”‚   â”‚ ... â”‚ ... â”‚ ... â”‚ ... â”‚ &lt;â”€â”€ a state set, S(2)
   â”‚      V   â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜
   â”‚   â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”
   â”‚   â”‚ ... â”‚ ... â”‚ ... â”‚ &lt;â”€â”€ another state set, S(1)
   V   â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”‚â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”   â”‚
â”‚ ... â”‚ ... â”‚ ... â”‚   â””â”€â”€ an Earley item
â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜
</code></pre>

<p>(We can do nice optimisations about storing the state sets
contiguously in memory, but let's ignore that for now.  New state set,
new array.)</p>

<h3>The big array and the input</h3>

<p>Earley parsers are incremental parsers:  as soon as they have read a
token, they gather as much information as they can about the partial
parses that make sense.  Concretely, this means the big array, S, is
constructed piece by piece, with one element per input token (plus one
initial element).</p>

<p>Here is what S looks like when we have read the first two tokens.</p>

<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”
â”‚ S(0) â”‚ S(1) â”‚ S(2) â”‚
â””â”€â”€â”¬â”€â”€â”€â”´â”€â”€â”¬â”€â”€â”€â”´â”€â”€â”¬â”€â”€â”€â”˜
   V      V      V
   â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”
   â”‚  1   â”‚  +   â”‚  (   â”‚  2   â”‚  *   â”‚  3   â”‚  -   â”‚  4   â”‚  )   â”‚
   â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜
</code></pre>

<p>The arrows here indicate the current position of each state set in S.
Those positions are <em>between</em> tokens.  Which makes sense, considering a
character is either read, or not read.  When <code>S(2)</code> is created, it
means we have read the first 2 characters.</p>

<p><code>S(0)</code> is created before we read anything.  That's the initial state.
When we will be finished with this input, if all goes well, we will
have created 10 state sets, up to <code>S(9)</code>.  This last state set is
created when we have read everything.</p>

<h2>Start up</h2>

<p>The parsing starts by initialising the first state set.  We typically
chose the rules by name.  In our "hello world", that would be every
rule named <code>Sum</code>.</p>

<pre><code>   â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”
   â”‚  1   â”‚  +   â”‚  (   â”‚  2   â”‚  *   â”‚  3   â”‚  -   â”‚  4   â”‚  )   â”‚
   â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”
â”‚ S(0) â”‚ &lt;â”€â”€ Our big array, S, contains only one state set.
â””â”€â”€â”¬â”€â”€â”€â”˜
   â”‚     â”Œâ”€â”€ Our only state set, S(0), contains 2 Earley items.
   V     V
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Sum -&gt; â€¢ Sum [+-] Product (0) â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Sum -&gt; â€¢ Product          (0) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>

<p>Note how I produced the items:</p>

<ul>
<li>We start at the beginning, and have read no input yet.  The current
position is therefore <code>(0)</code>.  I put the item in <code>S(0)</code>.</li>
<li>The items are brand new So, their start position is the same as the
current position: <code>(0)</code>.  Which you can see at the right of both
items.</li>
<li>As brand new items, nothing has been parsed yet.  Everything is yet
to be done (or tested).  We put the fat dot at the very beginning of
the item.</li>
</ul>

<h2>Main loop</h2>

<p>Now that we have initialised our data, we can loop over it.  There are
two loops to consider: an inner loop, which loops over a single state
set, and an outer loop, which loops over the main array of state set.</p>

<h3>Inner loop</h3>

<p>Basically, we go over each Earley item in the current state set.  When
we begin the algorithm, the current state set is <code>S(0)</code> (we'll do the
rest later).</p>

<p>While going over the items, we may add even <em>more</em> items to either the
current state, or the next one.  (For the first inner loop, this means
<code>S(0)</code> and <code>S(1)</code>).  We continue until there are no more items in the
current state set to process.  This can go on for a while: whenever we
add an item to the current state set, it will need to be processed just
like the others.</p>

<p>This looks like this:</p>

<pre><code>             current
              item
                â”‚
                V
current      â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”
state set â”€&gt; â”‚ ... â”‚ ... â”‚
             â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜
</code></pre>

<p>Nothing to add, let's try the next Earley item:</p>

<pre><code>                   current
                    item
                      â”‚
                      V
current      â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”
state set â”€&gt; â”‚ ... â”‚  !  â”‚
             â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜
</code></pre>

<p>Ah, apparently, we need to add an item:</p>

<pre><code>                   current
                    item
                      â”‚     â”Œâ”€â”€The item we just added
                      V     V
current      â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”
state set â”€&gt; â”‚ ... â”‚  !  â”‚ ... â”‚
             â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜
</code></pre>

<p>Done, now let's go to the next item (there wasn't one, but now there
is).</p>

<pre><code>                          current
                           item
                            â”‚
                            V
current      â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”
state set â”€&gt; â”‚ ... â”‚  !  â”‚ !!! â”‚
             â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜
</code></pre>

<p>Ah, this one's different.  We need to add an item to the <em>next</em> state
set!  We create this state set if necessary, then add an Earley item
to it.</p>

<pre><code>                          current
                           item
                            â”‚
                            V
current      â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”
state set â”€&gt; â”‚ ... â”‚  !  â”‚ !!! â”‚
             â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜

next         â”Œâ”€â”€â”€â”€â”€â”
state set â”€&gt; â”‚ ... â”‚
             â””â”€â”€â”€â”€â”€â”˜
                ^
                â””â”€â”€The item we just added
</code></pre>

<p>We have finished processing the current state, we can now process the
next one (there wasn't one originally, but now there is), and so on.</p>

<h3>Outer loop</h3>

<p>The outer loop works similarly: Run the inner loop over <code>S(0)</code>.
Repeat the process with the next state set (which hopefully has just
been created), and so on until there are no more state sets to
process.  Given a grammar and an input, we will start with something
like this:</p>

<pre><code>   â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”
   â”‚  1   â”‚  +   â”‚  (   â”‚  2   â”‚  *   â”‚  3   â”‚  -   â”‚  4   â”‚  )   â”‚
   â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”
â”‚ S(0) â”‚
â””â”€â”€â”¬â”€â”€â”€â”˜
   â”‚
   V
â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”
â”‚ ... â”‚ ... â”‚
â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜
</code></pre>

<p>Then we run the inner loop over <code>S(0)</code>, generating some more Earley
items and one state set in the process:</p>

<pre><code>   â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”
   â”‚  1   â”‚  +   â”‚  (   â”‚  2   â”‚  *   â”‚  3   â”‚  -   â”‚  4   â”‚  )   â”‚
   â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”
â”‚ S(0) â”‚ S(1) â”‚
â””â”€â”€â”¬â”€â”€â”€â”´â”€â”€â”¬â”€â”€â”€â”˜
   â”‚      â”‚
   â”‚      V
   â”‚   â”Œâ”€â”€â”€â”€â”€â”
   â”‚   â”‚ ... â”‚
   V   â””â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”
â”‚ ... â”‚ ... â”‚ ... â”‚
â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜
</code></pre>

<p>Now we run the inner loop over <code>S(1)</code>, and generate some more data:</p>

<pre><code>   â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”
   â”‚  1   â”‚  +   â”‚  (   â”‚  2   â”‚  *   â”‚  3   â”‚  -   â”‚  4   â”‚  )   â”‚
   â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”
â”‚ S(0) â”‚ S(1) â”‚ S(2) â”‚
â””â”€â”€â”¬â”€â”€â”€â”´â”€â”€â”¬â”€â”€â”€â”´â”€â”€â”¬â”€â”€â”€â”˜
   â”‚      â”‚      â”‚
   â”‚      â”‚      V
   â”‚      â”‚   â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”
   â”‚      â”‚   â”‚ ... â”‚ ... â”‚ ... â”‚ ... â”‚
   â”‚      V   â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜
   â”‚   â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”
   â”‚   â”‚ ... â”‚ ... â”‚ ... â”‚
   V   â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”
â”‚ ... â”‚ ... â”‚ ... â”‚
â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜
</code></pre>

<p>And so on until we can't generate more state sets (either because we
reached the end of the input, or because the input "stopped making
sense").  I didn't represent all state sets, but you get the idea:</p>

<pre><code>   â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”
   â”‚  1   â”‚  +   â”‚  (   â”‚  2   â”‚  *   â”‚  3   â”‚  -   â”‚  4   â”‚  )   â”‚
   â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”
â”‚ S(0) â”‚ S(1) â”‚ S(2) â”‚ S(3) â”‚ S(4) â”‚ S(5) â”‚ S(6) â”‚ S(7) â”‚ S(8) â”‚ S(9) â”‚
â””â”€â”€â”¬â”€â”€â”€â”´â”€â”€â”¬â”€â”€â”€â”´â”€â”€â”¬â”€â”€â”€â”´â”€â”€â”¬â”€â”€â”€â”´â”€â”€â”¬â”€â”€â”€â”´â”€â”€â”¬â”€â”€â”€â”´â”€â”€â”¬â”€â”€â”€â”´â”€â”€â”¬â”€â”€â”€â”´â”€â”€â”¬â”€â”€â”€â”´â”€â”€â”¬â”€â”€â”€â”˜
   â”‚      â”‚      â”‚      â”‚      â”‚      â”‚      â”‚      â”‚      â”‚      â”‚
   â”‚      â”‚      â”‚      V      V      V      V      V      V      V
   â”‚      â”‚      â”‚     ...    ...    ...    ...    ...    ...    ...
   â”‚      â”‚      V
   â”‚      â”‚   â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”
   â”‚      â”‚   â”‚ ... â”‚ ... â”‚ ... â”‚ ... â”‚
   â”‚      V   â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜
   â”‚   â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”
   â”‚   â”‚ ... â”‚ ... â”‚ ... â”‚
   V   â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”
â”‚ ... â”‚ ... â”‚ ... â”‚
â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜
</code></pre>

<h2>Prediction, Scan, and Completion</h2>

<p>There are three specific ways of adding new Earley items to our
data.  Which way we choose depends on the item we are currently
examining.</p>

<ul>
<li><strong>Prediction</strong>.  The symbol at the right of the fat dot is
non-terminal.  We add the the corresponding rules to the current
state set.</li>
<li><p><strong>Scan</strong>.  The symbol at the right of the fat dot is terminal.  We
check if the input matches this symbol.  If it does, we add this
item (advanced one step) to the <em>next</em> state set.</p></li>
<li><p><strong>Completion</strong>.  There is nothing at the right of the fat dot.  This
means we have a successful partial parse.  We look for the parent
items, and add them (advanced one step) to this state set.</p></li>
</ul>

<h3>Prediction</h3>

<p>Let's go back to our initialised data.  We must now examine the first
Earley Item.</p>

<pre><code>   â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”
   â”‚  1   â”‚  +   â”‚  (   â”‚  2   â”‚  *   â”‚  3   â”‚  -   â”‚  4   â”‚  )   â”‚
   â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”
â”‚ S(0) â”‚
â””â”€â”€â”¬â”€â”€â”€â”˜
   â”‚
   V
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Sum -&gt; â€¢ Sum [+-] Product (0) â”‚ &lt;â”€ prediction
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Sum -&gt; â€¢ Product          (0) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>

<p>At the right of the fat dot, there is <code>Sum</code>, a non-terminal symbol.
We must perform a prediction.  Why?  Because we're trying to parse the
grammar rule embedded in this item.  What's just after the fat dot?  A
<code>Sum</code>.  Does this <code>Sum</code> actually begins by a <code>Sum</code>?  Well, we have to
try if we want to know.  So we look up the Grammar, and see 2 rules
named "Sum":</p>

<pre><code>Sum -&gt; Sum [+-] Product
Sum -&gt; Product
</code></pre>

<p>This means we must add the following two items to <code>S(0)</code>:</p>

<pre><code>Sum -&gt; â€¢ Sum [+-] Product (0)
Sum -&gt; â€¢ Product          (0)
       â”‚                   â”‚
       â”‚                   â”” The item is predicted in S(0), so
       â”‚                     we set the starting point at (0).
       â”‚
       â”” We put the dot at the beginning of the rule.
</code></pre>

<p>Now we can add those items at the end of <code>S(0)</code>.</p>

<pre><code>   â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”
   â”‚  1   â”‚  +   â”‚  (   â”‚  2   â”‚  *   â”‚  3   â”‚  -   â”‚  4   â”‚  )   â”‚
   â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”
â”‚ S(0) â”‚
â””â”€â”€â”¬â”€â”€â”€â”˜
   â”‚
   V
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Sum -&gt; â€¢ Sum [+-] Product (0) â”‚ &lt;â”€ prediction
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Sum -&gt; â€¢ Product          (0) â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤â”€â”
â”† Sum -&gt; â€¢ Sum [+-] Product (0) â”† â”‚
â”œâ”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”¤ â”œâ”€&gt; These 2 are redundant
â”† Sum -&gt; â€¢ Product          (0) â”† â”‚
â””â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”˜â”€â”˜
</code></pre>

<p>Now we have a problem: this redundancy will drop us in an infinite
loop: since the first symbol of a rule named "Sum" is <em>also</em> "Sum", we
will keep predicting sums until we run out of memory.  This is a
classic problem with most top-down parsers, and the reason why they
can't handle left-recursive grammars.</p>

<p>So we take one little precaution: <em>no duplicate</em>.  The same items give
the same results anyway, so why waste work?  That way we avoid
infinite loops â€”all of them.  So don't worry about left-recursive
grammars, right-recursive grammars, magical grammarsâ€¦ they Just Workâ„¢.</p>

<p><em>(Okay, that was a lie.  Some grammars still won't work.  We need
another little precaution, which cannot be explained at this point.)</em></p>

<p>With this in mind, we go examine the next Earley item.  We must still
perform a prediction, this time over <code>Product</code>.  (Basically, we're
trying to see if this <code>Sum</code> begins with a <code>Product</code>.)</p>

<pre><code>   â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”
   â”‚  1   â”‚  +   â”‚  (   â”‚  2   â”‚  *   â”‚  3   â”‚  -   â”‚  4   â”‚  )   â”‚
   â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”
â”‚ S(0) â”‚
â””â”€â”€â”¬â”€â”€â”€â”˜
   â”‚
   V
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Sum     -&gt; â€¢ Sum     [+-] Product (0) â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Sum     -&gt; â€¢ Product              (0) â”‚ &lt;â”€ prediction
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤â”€â”
â”† Product -&gt; â€¢ Product [*/] Factor  (0) â”† â”‚
â”œâ”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”¤ â”œâ”€&gt; These 2 are new
â”† Product -&gt; â€¢ Factor               (0) â”† â”‚
â””â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”˜â”€â”˜
</code></pre>

<p>Since those are not duplicates we actually add them to <code>S(0)</code>.</p>

<h3>Scan</h3>

<p>We keep looping over the items, predicting everything until we reach
this Earley item:</p>

<pre><code>   â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”
   â”‚  1   â”‚  +   â”‚  (   â”‚  2   â”‚  *   â”‚  3   â”‚  -   â”‚  4   â”‚  )   â”‚
   â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”
â”‚ S(0) â”‚
â””â”€â”€â”¬â”€â”€â”€â”˜
   â”‚
   V
â”† ...                                   â”†
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Factor  -&gt; â€¢ '(' Sum ')'          (0) â”‚ &lt;â”€ scan
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”† ...                                   â”†
</code></pre>

<p>Now we can't predict any more: at the right of the fat dot, there is a
<em>terminal</em> symbol.  How do we <em>try</em> a terminal symbol?  We scan it.
First we see if the terminal symbol (an open parens) applies to the
current character (the digit '1').  Since '1' is not an open parens,
the scan fails.  We continue the loop without doing anything.</p>

<p>The next scan looks like this:</p>

<pre><code>   â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”
   â”‚  1   â”‚  +   â”‚  (   â”‚  2   â”‚  *   â”‚  3   â”‚  -   â”‚  4   â”‚  )   â”‚
   â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”
â”‚ S(0) â”‚
â””â”€â”€â”¬â”€â”€â”€â”˜
   â”‚
   V
â”† ...                                   â”†
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Number  -&gt; â€¢ [0-9] Number         (0) â”‚ &lt;â”€ scan
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”† ...                                   â”†
</code></pre>

<p>Here, the non-terminal symbol at the right of the fat dot is <code>[0-9]</code>,
and the digit '1' does match that terminal symbol.  Test successful!
So, we copy the Earley item we're examining over to the next state
set, with a slight modification:</p>

<pre><code>   â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”
   â”‚  1   â”‚  +   â”‚  (   â”‚  2   â”‚  *   â”‚  3   â”‚  -   â”‚  4   â”‚  )   â”‚
   â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”¬â”„â”„â”„â”„â”„â”„â”
â”‚ S(0) â”‚ S(1) â”†
â””â”€â”€â”¬â”€â”€â”€â”´â”„â”„â”„â”„â”„â”„â”˜
   â”‚      â”‚
   â”‚      V
   â”‚    â”Œâ”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”
   â”‚    â”† Number -&gt; [0-9] â€¢ Number (0) â”†
   â”‚    â””â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”‚â”„â”„â”„â”„â”„â”„â”„â”„â”„â”‚â”„â”„â”˜
   â”‚                      â”‚         â”‚
   â”‚                      â”‚         â”” The starting point
   â”‚                      â”‚           is unchanged.
   â”‚                      â”‚
   â”‚                      â”” The fat dot is shifted
   V                        one step to the right.
â”† ...                                   â”†
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Number  -&gt; â€¢ [0-9] Number         (0) â”‚ &lt;â”€ scan
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”† ...                                   â”†
</code></pre>

<p>This time, we've done some significant work: we have tried many
things, and this is our first success!  At last, we managed to move a
fat dot one step to the right.  Now this is not a <em>confirmed</em> success,
since the fat dot is not completely off to the right yet.  But that's
a start.</p>

<h3>Completion</h3>

<p>We continue our main loop, finish <code>S(0)</code>, and process <code>S(1)</code>.  At some
point, we get to this:</p>

<pre><code>   â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”
   â”‚  1   â”‚  +   â”‚  (   â”‚  2   â”‚  *   â”‚  3   â”‚  -   â”‚  4   â”‚  )   â”‚
   â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”
â”‚ S(0) â”‚ S(1) â”‚
â””â”€â”€â”¬â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜
   â”‚      â”‚
   â”‚      V
   â”‚    â”† ...                                  â”†
   â”‚    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
   â”‚    â”‚ Number -&gt; [0-9] â€¢                (0) â”‚ &lt;â”€ completion
   â”‚    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
   â”‚    â”† ...                                  â”†
   V
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ...                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”† ...                                   â”†
</code></pre>

<p>Here there is no symbol at the right side of the fat dot.  At this
point, things get <em>real</em> interesting: we have a successful partial
parse.  An actual, confirmed success: between the starting point of
the item (0), and its current position (1), the string <code>"1"</code> is a
<code>Number</code>.</p>

<p>We do not stop there however: This <code>Number</code> may be a fluke, but it
may also be part of something bigger.  Actually, Earley's algorithm
pretty much <em>guarantees</em> it will be part of something bigger.  This
item doesn't come from nowhere: there's a whole chain of predictions,
scans, and completions to get there.</p>

<p>Imagine we have an item like this ('a', 'b', and 'c' are symbols, and
'i' is an integer):</p>

<pre><code>Rule -&gt; a b c â€¢  (i)
</code></pre>

<p>The fact that this item even <em>exist</em> means the following items also
exist somewhere:</p>

<pre><code>Foo -&gt;   a   b â€¢ c  (i)
Foo -&gt;   a â€¢ b   c  (i)
Foo -&gt; â€¢ a   b   c  (i)
</code></pre>

<p>And the last of them can only exist in <code>S(i)</code>: the state set where it
was predicted.  We're not interested in those items however.  What we
<em>really</em> want is the items that might have triggered the original
prediction.  <em>Might</em> have.  Only one item actually triggered the
original prediction, but there's often more than one path, and we want
to capture them all.  Anyway, those rules are the rules in <code>S(i)</code> that
look like this:</p>

<pre><code>Bar -&gt; a b â€¢ Foo c d  (j)
</code></pre>

<p>That is, any rule in <code>S(i)</code> that has the rule <code>Foo</code> right next to the
fat dot.  <em>Those</em> are the "something" bigger <code>Foo</code> is a part of.  Now
the purpose of starting points should be obvious.  With them, we can
jump straight to the interesting state set, and retrieve the sets we
want.</p>

<p>Enough with the side quest.  We were triggering a completion with this
item:</p>

<pre><code>â”† ...                                  â”†
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”† Number -&gt; [0-9] â€¢                (0) â”†
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”† ...                                  â”†
</code></pre>

<p>So, we search <code>S(0)</code> for any item that has <code>Number</code> right next to the
dot:</p>

<pre><code>    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤we must search hereâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                                       â”‚
â”Œâ”€â”€â”€Vâ”€â”€â”¬â”€â”€â”€â”€â”€â”€â”                             â”‚
â”‚ S(0) â”‚ S(1) â”‚                             â”‚
â””â”€â”€â”¬â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜                             â”‚
   â”‚      â”‚                                 â”‚
   â”‚      V                                 â”‚
   â”‚    â”† ...                               â”‚  â”†
   â”‚    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”¤
   â”‚    â”‚ Number -&gt; [0-9] â€¢                (0) â”‚ &lt;â”€ completion
   â”‚    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
   â”‚    â”† ...                                  â”†
   V
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Sum     -&gt; â€¢ Sum     [+-] Product (0) â”‚ Nope
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Sum     -&gt; â€¢ Product              (0) â”‚ Nope
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Product -&gt; â€¢ Product [*/] Factor  (0) â”‚ Nope
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Product -&gt; â€¢ Factor               (0) â”‚ Nope
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Factor  -&gt; â€¢ '(' Sum ')'          (0) â”‚ Nope
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Factor  -&gt; â€¢ Number               (0) â”‚ FOUND ONE!
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Number  -&gt; â€¢ [0-9] Number         (0) â”‚ Nope
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Number  -&gt; â€¢ [0-9]                (0) â”‚ Nope
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>

<p>Now we just have to complete the items we have found.  This is very
similar to a successful scan.  The only difference is, we moved the
fat dot over a <em>non-terminal</em> symbol:</p>

<pre><code>   â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”
   â”‚  1   â”‚  +   â”‚  (   â”‚  2   â”‚  *   â”‚  3   â”‚  -   â”‚  4   â”‚  )   â”‚
   â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”
â”‚ S(0) â”‚ S(1) â”‚
â””â”€â”€â”¬â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜
   â”‚      â”‚
   â”‚      V
   â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚    â”‚ Number -&gt; [0-9] â€¢ Number         (0) â”‚
   â”‚    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
   â”‚    â”‚ Number -&gt; [0-9] â€¢                (0) â”‚ &lt;â”€ completion
   â”‚    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤    trigger
   â”‚    â”‚ Number -&gt; â€¢ [0-9] Number         (1) â”‚
   â”‚    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
   â”‚    â”‚ Number -&gt; â€¢ [0-9]                (1) â”‚
   â”‚    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
   â”‚    â”† Factor  -&gt; Number â€¢              (0) â”† completed item
   â”‚    â””â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”‚â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”‚â”„â”„â”˜
   â”‚                        â”‚               â”‚
   â”‚                        â”‚               â”” The starting point
   â”‚                        â”‚                 is unchanged.
   â”‚                        â”‚
   â”‚                        â”” The fat dot is shifted
   V                          one step to the right.
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Sum     -&gt; â€¢ Sum     [+-] Product (0) â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Sum     -&gt; â€¢ Product              (0) â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Product -&gt; â€¢ Product [*/] Factor  (0) â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Product -&gt; â€¢ Factor               (0) â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Factor  -&gt; â€¢ '(' Sum ')'          (0) â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Factor  -&gt; â€¢ Number               (0) â”‚ Item to complete
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Number  -&gt; â€¢ [0-9] Number         (0) â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Number  -&gt; â€¢ [0-9]                (0) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>

<p>Note that there may be more than one item to complete.  And in some
cases, like the starting rule, there may be no item at all to
complete.  Be careful with those edge cases.</p>

<h2>After the end</h2>

<p>Eventually, the algorithm will stop, and you will end up with a whole
slew of Earley items.  for the input <code>1+(2*3-4)</code>, it will be those:</p>

<pre><code>=== 0 ===
Sum     -&gt; â€¢ Sum [+-] Product     (0)
Sum     -&gt; â€¢ Product              (0)
Product -&gt; â€¢ Product [*/] Factor  (0)
Product -&gt; â€¢ Factor               (0)
Factor  -&gt; â€¢ '(' Sum ')'          (0)
Factor  -&gt; â€¢ Number               (0)
Number  -&gt; â€¢ [0-9] Number         (0)
Number  -&gt; â€¢ [0-9]                (0)

=== 1 ===
Number  -&gt; [0-9] â€¢ Number         (0)
Number  -&gt; [0-9] â€¢                (0)
Number  -&gt; â€¢ [0-9] Number         (1)
Number  -&gt; â€¢ [0-9]                (1)
Factor  -&gt; Number â€¢               (0)
Product -&gt; Factor â€¢               (0)
Sum     -&gt; Product â€¢              (0)
Product -&gt; Product â€¢ [*/] Factor  (0)
Sum     -&gt; Sum â€¢ [+-] Product     (0)

=== 2 ===
Sum     -&gt; Sum [+-] â€¢ Product     (0)
Product -&gt; â€¢ Product [*/] Factor  (2)
Product -&gt; â€¢ Factor               (2)
Factor  -&gt; â€¢ '(' Sum ')'          (2)
Factor  -&gt; â€¢ Number               (2)
Number  -&gt; â€¢ [0-9] Number         (2)
Number  -&gt; â€¢ [0-9]                (2)

=== 3 ===
Factor  -&gt; '(' â€¢ Sum ')'          (2)
Sum     -&gt; â€¢ Sum [+-] Product     (3)
Sum     -&gt; â€¢ Product              (3)
Product -&gt; â€¢ Product [*/] Factor  (3)
Product -&gt; â€¢ Factor               (3)
Factor  -&gt; â€¢ '(' Sum ')'          (3)
Factor  -&gt; â€¢ Number               (3)
Number  -&gt; â€¢ [0-9] Number         (3)
Number  -&gt; â€¢ [0-9]                (3)

=== 4 ===
Number  -&gt; [0-9] â€¢ Number         (3)
Number  -&gt; [0-9] â€¢                (3)
Number  -&gt; â€¢ [0-9] Number         (4)
Number  -&gt; â€¢ [0-9]                (4)
Factor  -&gt; Number â€¢               (3)
Product -&gt; Factor â€¢               (3)
Sum     -&gt; Product â€¢              (3)
Product -&gt; Product â€¢ [*/] Factor  (3)
Factor  -&gt; '(' Sum â€¢ ')'          (2)
Sum     -&gt; Sum â€¢ [+-] Product     (3)

=== 5 ===
Product -&gt; Product [*/] â€¢ Factor  (3)
Factor  -&gt; â€¢ '(' Sum ')'          (5)
Factor  -&gt; â€¢ Number               (5)
Number  -&gt; â€¢ [0-9] Number         (5)
Number  -&gt; â€¢ [0-9]                (5)

=== 6 ===
Number  -&gt; [0-9] â€¢ Number         (5)
Number  -&gt; [0-9] â€¢                (5)
Number  -&gt; â€¢ [0-9] Number         (6)
Number  -&gt; â€¢ [0-9]                (6)
Factor  -&gt; Number â€¢               (5)
Product -&gt; Product [*/] Factor â€¢  (3)
Sum     -&gt; Product â€¢              (3)
Product -&gt; Product â€¢ [*/] Factor  (3)
Factor  -&gt; '(' Sum â€¢ ')'          (2)
Sum     -&gt; Sum â€¢ [+-] Product     (3)

=== 7 ===
Sum     -&gt; Sum [+-] â€¢ Product     (3)
Product -&gt; â€¢ Product [*/] Factor  (7)
Product -&gt; â€¢ Factor               (7)
Factor  -&gt; â€¢ '(' Sum ')'          (7)
Factor  -&gt; â€¢ Number               (7)
Number  -&gt; â€¢ [0-9] Number         (7)
Number  -&gt; â€¢ [0-9]                (7)

=== 8 ===
Number  -&gt; [0-9] â€¢ Number         (7)
Number  -&gt; [0-9] â€¢                (7)
Number  -&gt; â€¢ [0-9] Number         (8)
Number  -&gt; â€¢ [0-9]                (8)
Factor  -&gt; Number â€¢               (7)
Product -&gt; Factor â€¢               (7)
Sum     -&gt; Sum [+-] Product â€¢     (3)
Product -&gt; Product â€¢ [*/] Factor  (7)
Factor  -&gt; '(' Sum â€¢ ')'          (2)
Sum     -&gt; Sum â€¢ [+-] Product     (3)

=== 9 ===
Factor  -&gt; '(' Sum ')' â€¢          (2)
Product -&gt; Factor â€¢               (2)
Sum     -&gt; Sum [+-] Product â€¢     (0)
Product -&gt; Product â€¢ [*/] Factor  (2)
Sum     -&gt; Sum â€¢ [+-] Product     (0)
</code></pre>

<p>Quite a mess.  Now the big question is, have we made it?  To know
that, we must look at the last state set:</p>

<pre><code>=== 9 ===
Factor  -&gt; '(' Sum ')' â€¢          (2)
Product -&gt; Factor â€¢               (2)
Sum     -&gt; Sum [+-] Product â€¢     (0)
Product -&gt; Product â€¢ [*/] Factor  (2)
Sum     -&gt; Sum â€¢ [+-] Product     (0)
</code></pre>

<p>First this is the set number 9 (or the 10th set).  The input has
precisely 9 characters.  So, first good news, the whole input made
sense.</p>

<p>This is not enough however.  We are looking for items that:</p>

<ul>
<li>are complete (the fat dot is at the end),</li>
<li>have started at the beginning (state set 0),</li>
<li>have the same name that has been chosen at the beginning ("Sum").</li>
</ul>

<p>There is one such item in S(9):</p>

<pre><code>Sum -&gt; Sum [+-] Product â€¢  (0)
</code></pre>

<p>We Win!</p>

<h3>Failure modes</h3>

<p>There are 2 ways to fail:</p>

<ul>
<li><p>We may fail to parse the whole input.  This is because an invalid
token caused it to stop making sense at this point.  This is what
happens when you try "<code>1+%</code>": the parse stops at the second character,
fails at the third, then stops.</p></li>
<li><p>We may parse the whole input, but fail to make a complete parse out
of it.  This is what happens when you try "<code>1+</code>".  This is a valid
beginning of a <code>Sum</code>, but the last part is missing, and we can't
finish the parse.</p></li>
</ul>

<p>In both cases, you get the following Earley items:</p>

<pre><code>=== 0 ===
Sum     -&gt; â€¢ Sum [+-] Product     (0)
Sum     -&gt; â€¢ Product              (0)
Product -&gt; â€¢ Product [*/] Factor  (0)
Product -&gt; â€¢ Factor               (0)
Factor  -&gt; â€¢ '(' Sum ')'          (0)
Factor  -&gt; â€¢ Number               (0)
Number  -&gt; â€¢ [0-9] Number         (0)
Number  -&gt; â€¢ [0-9]                (0)

=== 1 ===
Number  -&gt; [0-9] â€¢ Number         (0)
Number  -&gt; [0-9] â€¢                (0)
Number  -&gt; â€¢ [0-9] Number         (1)
Number  -&gt; â€¢ [0-9]                (1)
Factor  -&gt; Number â€¢               (0)
Product -&gt; Factor â€¢               (0)
Sum     -&gt; Product â€¢              (0)
Product -&gt; Product â€¢ [*/] Factor  (0)
Sum     -&gt; Sum â€¢ [+-] Product     (0)

=== 2 ===
Sum     -&gt; Sum [+-] â€¢ Product     (0)
Product -&gt; â€¢ Product [*/] Factor  (2)
Product -&gt; â€¢ Factor               (2)
Factor  -&gt; â€¢ '(' Sum ')'          (2)
Factor  -&gt; â€¢ Number               (2)
Number  -&gt; â€¢ [0-9] Number         (2)
Number  -&gt; â€¢ [0-9]                (2)
</code></pre>

<p><em>(We get the same Earley items because this grammar makes no
 difference between an input that stops making sense, and an input
 that just stops. To make that difference, we need a rule that uses an
 "end of input" token explicitly.)</em></p>

<p>Note that in both examples, there <em>is</em> a valid parse: the number <code>1</code>,
which is a <code>Sum</code> by itself.  This is evidenced by the presence of this
Earley item in <code>S(1)</code>:</p>

<pre><code>Sum -&gt; Product â€¢  (0)
</code></pre>

<p>I say this because in some cases, you just want to parse a header.  Of
course the input will stop making sense at some point.</p>

<h2>Let's do this!</h2>

<p>You should now be able to implement a Lua recogniser.  It will work
for any grammar, except for <em>one important limitation</em>: It handles
empty rules badly.  We'll correct this bug <a href="empty-rules">next time</a>.</p>

<p>In the mean time, here is a <a href="recogniser.lua">recogniser in Lua</a>.  To
use it, just run the lua interpreter on it in the command line, like
this:</p>

<pre><code>$ lua recogniser.lua
</code></pre>

<p>It has been tested with lua 5.2.3 on a Debian machine.  It should work
on 5.1 as well, on any machine.</p>

<p>If you don't know Lua, don't worry, it mostly looks like pseudocode.
Use it at your own peril though: there is still that bug about empty
rules.</p>

<h2>Source code</h2>

<p>You should be able to read it even if you don't know Lua (I did my
best to avoid Lua specific idioms). The only tricky bit lie in the
<a href="http://lua-users.org/wiki/TablesTutorial">tables</a>.</p>

<p>First, an example grammar:</p>

<pre><code>local Grammar = {
   start_rule_name = 'Sum',
   { name = 'Sum'    , 'Sum'      , class('+-'), 'Product'},
   { name = 'Sum'    , 'Product'  ,                       },
   { name = 'Product', 'Product'  , class('*/'), 'Factor' },
   { name = 'Product', 'Factor'   ,                       },
   { name = 'Factor' , char('(')  , 'Sum', char(')')      },
   { name = 'Factor' , 'Number'                           },
   { name = 'Number' , range('09'), 'Number'              },
   { name = 'Number' , range('09'),                       },
}
</code></pre>

<p>then how to use it:</p>

<pre><code>local input = "1+(2*3+4)"
local S     = build_items(Grammar, input)
print_S(S, Grammar)              -- print all the internal state
diagnose(S, Grammar, input)      -- tell if the input is OK or not
</code></pre>

<p>Now the main loop:</p>

<pre><code>local function build_items(grammar, input)
   -- Earley sets
   local S = {{}}
   -- put start item(s) in S[1]
   for i = 1, #grammar do
      if grammar[i].name == grammar.start_rule_name then
         unsafe_append(S[1], { rule  = i,
                               start = 1,
                               next  = 1 })
      end
   end
   -- populate the rest of S[i]
   local i = 1
   while i &lt;= #S do
      local j = 1
      while j &lt;= #S[i] do
         local symbol = next_symbol(grammar, S[i][j])
         if     type(symbol) == "nil"      then complete(S, i, j, grammar)
         elseif type(symbol) == "function" then scan    (S, i, j, symbol, input)
         elseif type(symbol) == "string"   then predict (S, i,    symbol, grammar)
         else error("illegal rule")
         end
         j = j + 1
      end
      i = i + 1
   end
   return S
end
</code></pre>

<p>The prediction step:</p>

<pre><code>local function predict(S, i, symbol, grammar)
   for rule_index, rule in ipairs(grammar) do
      if rule.name == symbol then
         append(S[i], { rule  = rule_index,
                        next  = 1 ,
                        start = i })
      end
   end
end
</code></pre>

<p>The scan step:</p>

<pre><code>local function scan(S, i, j, symbol, input)
   local item = S[i][j]
   if symbol(input, i) then -- terminal symbols are predicates
      if S[i+1] == nil then S[i+1]  = {} end
      unsafe_append(S[i+1], { rule  = item.rule,
                              next  = item.next + 1,
                              start = item.start })
   end
end
</code></pre>

<p>The completion step:</p>

<pre><code>local function complete(S, i, j, grammar)
   local item = S[i][j]
   for old_item_index, old_item in ipairs(S[item.start]) do
      if next_symbol(grammar, old_item) == name(grammar, item) then
         append(S[i], { rule  = old_item.rule,
                        next  = old_item.next + 1,
                        start = old_item.start })
      end
   end
end
</code></pre>

<p>Some utility functions:</p>

<pre><code>-- next element in the rule of this item
local function next_symbol(grammar, item)
   return grammar[item.rule][item.next]
end

-- gets the name of the rule pointed by the item
local function name(grammar, item)
   return grammar[item.rule].name
end

-- compares two items for equality (needed for safe append)
local function equal(item1, item2)
   return item1.rule  == item2.rule
      and item1.start == item2.start
      and item1.next  == item2.next
end

-- Adds an item at the end of the Earley set
local function unsafe_append(set, item)
   set[#set+1] = item
end

-- Adds an item at the end of the Earley set, **unless already present**
local function append(set, item)
   for i = 1, #set do
      if equal(item, set[i]) then
         return
      end
   end
   unsafe_append(set, item) -- the item wasn't already there, we add it
end
</code></pre>

<p>That should be enough.  In any case, the
<a href="recogniser.lua">full source code</a> is still available.</p>

 </article>

    <nav>
      <a href="/">Home</a>
      
<ul>
<li>
<a href="/articles/">
My essays/
</a>

</li>
<li>
<a href="/projects/">
Projects/
</a>

</li>
<li>
<a href="/tutorials/">
Tutorials/
</a>
<ul>
<li>
<a href="/tutorials/poly1305-design">
The design of Poly1305
</a>

</li>
<li>
<a href="/tutorials/chacha20-design">
The design of Chacha20
</a>

</li>
<li>
<a href="/tutorials/monty-hall">
Monty Hall: the Complete and Definitive Solution
</a>

</li>
<li>
<a href="/tutorials/earley-parsing/">
Earley Parsing Explained/
</a>
<ul>
<li>
<a href="/tutorials/earley-parsing/what-and-why">
What is Earley parsing, and why you should care?
</a>

</li>
<li>
<a href="/tutorials/earley-parsing/chart-parsing">
Chart Parsing
</a>

</li>
<li>
<a href="/tutorials/earley-parsing/recogniser">
The Recogniser
</a>

</li>
<li>
<a href="/tutorials/earley-parsing/empty-rules">
Empty Rules
</a>

</li>
<li>
<a href="/tutorials/earley-parsing/right-recursion">
Optimising Right Recursion
</a>

</li>
<li>
<a href="/tutorials/earley-parsing/parser">
The Parser
</a>

</li>
<li>
<a href="/tutorials/earley-parsing/semantic-actions">
Semantic Actions
</a>

</li>
</ul>
</li>
<li>
<a href="/tutorials/avoid-assignment">
How to avoid the assignment statement
</a>

</li>
<li>
<a href="/tutorials/from-imperative-to-functional">
From Imperative to Functional: how to make the leap.
</a>

</li>
<li>
<a href="/tutorials/ultimate-css-layout">
My ultimate CSS layout
</a>

</li>
</ul>
</li>
<li>
<a href="/contact">
Contact me
</a>

</li>
</ul>

    </nav>

    <footer>
      Contact, suggestions: Send me an email at
      <a href="mailto:l@loup-vaillant.fr">l@loup-vaillant.fr</a><br>
      <a href="/updates">Atom feed</a><br>
      Built with <a href="/projects/ussm">USSM</a>
    </footer>
  


</body></html>Ytext/htmlUUTF-8_;http://loup-vaillant.fr/tutorials/earley-parsing/recogniserP¢Ô_WebResourceResponseOqbplist00ÔnoX$versionX$objectsY$archiverT$top † ¯!#)*0123OPQRSTUVWXYZ[\]^_`abcdeiU$nullİ	
 !"R$6S$10R$2R$7R$3S$11R$8V$classR$4R$9R$0R$5R$1€	€€€ € €€€Ó$%'(WNS.base[NS.relative€ €€_!http://loup-vaillant.fr/style.cssÒ+,-.Z$classnameX$classesUNSURL¢-/XNSObject#A¾j!V£Ÿº ÈÓ456BNWNS.keysZNS.objects«789:;<=>?@A€	€
€€€€€€€€€«CEFGHIJKLM€€€€€€€€€€€€VServer\Content-TypeTVary]Last-ModifiedTEtag]Accept-RangesTDate_Content-Encoding^Content-LengthZKeep-AliveZConnection_Apache/2.2.16 (Debian)Xtext/css_Accept-Encoding_Mon, 29 Jun 2015 09:44:54 GMT_"32ad-60d-519a4f11b9180"Ubytes_Tue, 28 Feb 2017 21:32:33 GMTTgzipS548_timeout=15, max=100ZKeep-AliveÒ+,fg_NSMutableDictionary£fh/\NSDictionaryÒ+,jk_NSHTTPURLResponse£lm/_NSHTTPURLResponse]NSURLResponse_NSKeyedArchiverÑpq_WebResourceResponse€    # - 2 7 [ a |  ƒ † ‰ Œ  “ š    £ ¦ © « ­ ¯ ± ³ ´ ¶ ¸ º ¼ ¾ À Â É Ñ İ ß á ã &)2;=?FNYegikmoqsuwy{‡‰‹‘“•—™›Ÿ¦³¸ÆËÙŞñ /8Jj…‹«°´ÊÕÚğô2@RUk             r              mO/* reset */
header, nav, article, footer, body, html, pre code
{ display:block; margin:0; color:black; }

/* colors */
html, body { background-color:#fff8f0; }
footer     { background-color:#f0e4d0; }
pre code   { background-color:#f0e4d0; }

/* round corners, margins */
html     { margin:1.5em }
footer   { border-radius        : 1.5em;
           -moz-border-radius   : 1.5em;
           -webkit-border-radius: 1.5em;
           margin-bottom: 1.5em; padding: 1em; }
pre code { border-radius        : 1em;
           -moz-border-radius   : 1em;
           -webkit-border-radius: 1em;
           margin: 1em 0 1em 0;
           padding:0.5em;}
nav ul   { margin:  0;
           padding: 0 0 0 1em; }
header, nav, article { margin-bottom: 1.5em;
                       padding: 1em; }

/* style */
a:visited         { color: #822; }
a:hover           { color: #f50; }
code              { font-size: 120%; }
nav a             { text-decoration: none; }
nav ul, footer    { font-size: 0.83em; }
nav ul ul         { font-size: 1em; }
header blockquote { font-style: italic; } /* slogan */
header #logo      { float: right;
                    margin-bottom: 2em; }
h1                { font-size: 180% }
table tr td       { text-align: center;
                    padding: 5px; }
table tr th       { text-align: center;
                    padding: 5px; }

/* layout */
body    { width: 63em; margin: auto; }
article { float:left; margin-left:  18em; width: 42em;   }
nav     { float:left; margin-left: -61em; width: 14.5em; }
footer  { clear: both; }
Xtext/css_!http://loup-vaillant.fr/style.cssÔO%bplist00ÔfgX$versionX$objectsY$archiverT$top † ¯#)*0123KLMNOPQRSTUVWXYZ[\]aU$nullİ	
 !"R$6S$10R$2R$7R$3S$11R$8V$classR$4R$9R$0R$5R$1€	€€€ €€€€Ó$%'(WNS.base[NS.relative€ €€_#http://loup-vaillant.fr/penrose.pngÒ+,-.Z$classnameX$classesUNSURL¢-/XNSObject#A¾j!V£²W ÈÓ456@JWNS.keysZNS.objects©789:;<=>?€	€
€€€€€€€©ACDEFGHI€€€€€€€€€€VServer\Content-TypeTEtag]Last-ModifiedTDate]Accept-Ranges^Content-LengthZKeep-AliveZConnection_Apache/2.2.16 (Debian)Yimage/png_"22e3-f86-4ba5de191db80"_Sat, 03 Mar 2012 22:04:46 GMT_Fri, 03 Mar 2017 21:54:23 GMTUbytesT3974_timeout=15, max=98ZKeep-AliveÒ+,^__NSMutableDictionary£^`/\NSDictionaryÒ+,bc_NSHTTPURLResponse£de/_NSHTTPURLResponse]NSURLResponse_NSKeyedArchiverÑhi_WebResourceResponse€    # - 2 7 W ] x {  ‚ … ˆ Œ  – ™ œ Ÿ ¢ ¥ § © « ­ ¯ ° ² ´ ¶ ¸ º ¼ ¾ Å Í Ù Û İ ß
$'09;=DLWacegikmoqs}ƒ…‡‰‹‘˜¥ª¸½ËÚåğ	.Nnty™´¸ÅÊŞâö/             j              1O†‰PNG

   IHDR   ˆ   –   2¸0‹   gAMA  ±üa   PLTE                                                                                                                                                                        ÿ¡5ÿ¡5ÿ¡5ÿ 5ÿš3ÿš3ÿš3ÿš3ÿš3ÿš3ÿ™2ÿ™2ÿ™2ÿ™2ÿ™2ÿ™2ÿ™2ÿ™2ÿ™2ş˜2ş˜2ş˜2ı˜2ü—1û–1÷”1ô’0í/êŒ.â‡,Õ€+Ï}*Æw)Âu)»r)¸r-·r-·q-¶q-¶q-µp*´p,²o,²o,³o,²o,²o,²o,²o,²o,³p,´p,´p-µp-µp,´o,²o,±n,±n,°m,°m,¯m,¯l+®l*­k)­j'©h'§f&¤e& c'b'œa'œa'œa'›`'›_%™^$—]$”[#’Z"X"W!‹U‰SˆSƒR&ƒR&„R'ƒR'„R'†Q…Q‚Q&‚Q&‚Q&€P%€P&€P&€P&€P&€P&€P&€P&€P&€P&€P&P&P&P&P&P&P&ƒO‚O‚OO€O €O"€O$O%O%O%O%~N$|M$xJ#wJ#vI#vH#uH"uH!tG sFqEpDmCkBkBjAi@e>c=`;^9[8Y7W6U5S3Q2L/I-D*@'=&;$8"6!30.+
(	%	"



		                                       2&ï   8tRNS        	 #',4>DNT\hpz„™¤­´½ÃÉÒİâåèêîñóùşZe™s   bKGD ˆH  àIDATxÚÅÜ[LÙğ¾ÍªxÙu]uUÄÚ®`–´™Çy›D+¤¤Ïç¡>L¢VØ˜UtuíBşN²'éÓşİİÌƒ·à.( H¡r“K¹XŠ!iG…øüı? ®(mçÓú{n&ŸœùÍé™3¿ß±pl±.k—–°0üvãŞ|«Õfµæïßù!ë³ À@ŞÎŸ²Ûğı×O——•W\îŒ 8zpKæ!Û€Éß%» J¢$
’²¶ñ—@î–ÌBÖçƒ¿êDI|ÂÉò èàšÌA²rŠ¡õŸ>P,…½là%Šwge²Û•/·!	RÅ`İ™	È¶|`ò²}ÆR”\Ÿò¶¥r°üS‚˜($I(½É£07­¬àU¿Ó!&ÉáXDQöº´A²mÀH¹”ğ®¼—ˆ¦¤J"ÈÖ<ğ3×í)KÇï3ÀÁÍæCÖ,Ó)ˆzC(ı(<`2$+»/\IÔ’Ã5ôf5©²d§˜¨E‡(J¢tz°î0²5˜º^"²‡$Úÿˆ ¹_›É-Ãé$C¡´…7˜*Ë ë²‹Àc ãÖ¥r—S`$Gù£»Ö®
²ËŠ¥U€Ù‰®ŠI*§¤Ê¿yàùHx(ø¤74>5`²¶T0rƒ-àÀfƒìãà®ÕÉ3^¯Ç[}ñz@¤ó¤‘$¸:€cûAö‚Ÿ¸â&ïC&nO`
Ğ.9™k/íZÃÙ>pÈ„|HñTÿg_0ğ,KÂ‰Êğ‡·3B²Á÷T-c¼–@è/DÉ@ª´EıY á±‡¬gêz€X—(HFf•àø~H.Âçe’ Ü?¸äd€$ÉQ1ÆÃ¶cNÈà"I29{m
˜¨12İ
'jæÁúF¤ ½U2IF©êšú\FREptÌû¿ÔÙR¯')Â[ÛÄºNJWpt_jHÂ$eÈUõão«14Á•œãaÛ‘
rígtHÈÙ_¢ÀX¥¡YådMü¡­I!_€¯&úÂİz¥ŠÔ9ìÛ’I·¬Ë!o]ˆv8ŒıõG÷&†@_Ñ²ûÊ¯9aäoÙ^9Æ'\ X¸üCô‡LÎıÆN˜U$ÁyaÅ+ŞË+M&Lœ:K¥ŠĞ• U,Y¶WWcxêúFREWpdÏ§ß¥ÎVH•ŸÃ@ÔĞ¬"Ùk&xşöcÈ¦#ó?v	9ÿg)·šUj5,_ X¾<2‘#”ª`èp9Qzcàs²–C^‚™º~`¶ÍĞªI({
X7›!„Èî_&™JÉĞĞ¥ Û‘Éù¿bÀH¹ÃÈPi/pÀ!2!ı1 ÍĞ¬âh[Ä»ÒÕB!g~ fÿk70ë5<òLƒ²”*§ÙSEr\Xx{wLÈ¤úoo†Ëì’š…¥Œ5Bˆì•Cq ¥ÔÁ'Àó D&äâ ¹å`MZG
Ö˜!D–İMErÍï0BñV· bÜºo2„ÈŞ³OãÀ­R¦„S<6™!2ñÖ?¦o”°¬ú°ßl!„¸ÿfÛ.àp: 2©nYÀ+ı;ÆRYÜ¶>D®ûÑKdöT©Ô€ß:‡Ä5{ô«³‘¹ Û€„xzuşı¸f
·¦€œ0ÿç9æÛã© ÚzGd¦h[jˆ„®’e–ñp·E€¡2½ÏpÙ‹ãß¤†ÜÖ€¾:İ©"re˜¾l×=—T@Dyğ˜ïõè“ÈÚ‘WÀu–=7õA¨ÚĞşˆ\;—’"ËŞÚ -TÊ²4±‡uB¨ê¿Ó½Œ×»SNf-3Àh9ÓºQ¨^¥TQ†5 XçIcÀÔÕï÷ÇX *õ7Ñ„³Šì©Ò€§ØŒ’X¥Tõ= ‘kòŠou°*e^-:c2A¨ê¿Ó­áÍx½GştQôÏs`¤œõK (Aäş„RÕç™ôÔ.›UdBê‡™öw±Úƒ&f¥Ty8D;?HùLõ€Ü:e`“\jB©ïq˜~—*²·ºxÍø™øİVVĞİ „¨Ê'À›Ñº*™âşk
³®˜—®1 ›ªFG„RU¹ıLºj=Şú`æ¦‘M`Qªb­*5¡*¥ÍãÀl—¥ò¿ŸğpUéj ”ªªïI ¼gŠ¢$”Ş ´AEUé*!”RåN?Pal“æê~¨¼½Ò*!”>¾7²mU1
Ì>ñ½¿Îj!şGÀ÷ìÉQz	ïú—nËç‚ÎëÀÂø}EıàB‡H¢ıê40ùÈO?td"‰bÙú–32‘Î>è»§|r¡LB$áÔU`qünã
ÊDíµ“Àt«úñ]É(D…²`>èKp¡A$ÁÙúï*¿©Ÿ"I‚óòk,†(jÂedDJ.„H;Mi‡H¢Pæú|TıœIzb@¨IIÊH;Dp^njHÁH/D’5@¤]¥)i„H¢à
±P£¥MsÇ·¤"	'ºbÀÓû
Õb)7óŒ@$Áy!†7“U}õ‘–r{Ó¤¤r˜¨T§ƒÒîÔ¾¬i©:c>ä£ºCõ¦Şg„H‚Ğ›ıÃAé]›Í…'jâÀT«AA©2ŒÎLˆä¨æX’ƒRJÕq~‡y·U^ñA…A©2ŠCkMƒH‚£ã0Ü¤PÆh_q&A–Ê»0İêû‘¡*EìæÌ‚Ø+F€xà¶_e_‹ÈåL‚8\@|°A• |Î$ˆĞ67ù)³Cm-"o­9’Ê`ºİÇ>ªroÈÕY¶‘
²0 h$¥¾î(Ã™âÃ~#¥y°nÕ]ì”|£¦	mVØª_Ñ€=YúË¿’BÔÆ'í>#Œ;İÚ'õÇ)
â’ˆjä®¨¾Àój'-Y6íŠQˆÑ şÏø•
-k“Mšñ7Æı›˜ËHM…¨şÛ5ğ‡¾NTXôd¢6´O'.×·pÙ'.56¢<ïK\j¼6YñµY•úãI[:,gE›7½•ŞÌ¥hr±pÜL¤yD|­S<îü"UËBQ¬^ND¥JÓ F(Çq‡ğÄ#§	¢RßÓ˜Ö0Çq;º4ˆ_ÌãÓçD>1qNNDıõÑ#;×êí8ÚtœxÌ†¨Tizª¿¡r©l7øÎ{}ŒCTÚŠ¹›ÙÚãöo?»Â7£•ªí³L”ï÷«ûôÙ94š9šÃ`kC~ßB™S¾ó‡§Øsq4ø[iz
gë¶ı·©tsøÙÊCÎFÑÊıó ëY–ôÇ¯,+‘'`dĞöˆ‘æ}Ëò#x,×~ğüÈÏĞËöÖÔæQh Gİ²Â!?xßQä~„t¯UÕ¯ŸGaîf4§oÏfş÷¾¼ªcúê¾à·Õ¬vıl0q…,¥ÊŸˆê{»V©Úú|';X}2\{F&„TÍ~]oö÷Ã«9eå#²òŠÁ·U{eÙ=Ša¯úÊ½~ h5§XÃGZÜÄ{‹wSŞ•Æào49Rû±ÛŒÖ2‰ šbæhlÙi;eı@8ßh²/Pªro|Å9«=3'éÑ0ëòŠÁw¼Æ`câ—·»AEy«? +Åa9Û½Tµb4ôÎÛ9.İËùàµ‡JÚ’C÷Jë÷ ¼ø4OšÆ5ğ9ë3wÄÔÆ‚bğ}w>ØeW©rûÑPœgÒ¹NzİúÖ
ÌŸ²” ¾¦Ğ´ÜÆq™…pÜŞï ~´·õÑÃG­İƒ³ åoç¸ÌC¸»­ øEm€üì¯8î³@8Ûº¯Àj³Ù¬‡ìâLÛÏ×dee­áÒÿ>ù‰´ú„ô    IEND®B`‚Yimage/png_#http://loup-vaillant.fr/penrose.png    1 < N d ‚ ‘ ¨ÔÔ!Ô'ÔeÔfÔiÔrÔˆØıßßß;ßDãmò÷ó                           ó'